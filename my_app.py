"""Starter streaming app generated by PyTrickle CLI.

Edit the handlers to integrate your own model or processing pipeline.

Run:
    python my_app.py
"""

from __future__ import annotations

import asyncio
import logging
from dataclasses import dataclass
from typing import List


from pytrickle import StreamProcessor, VideoFrame, AudioFrame
from pytrickle.decorators import (
    audio_handler,
    model_loader,
    on_stream_stop,
    param_updater,
    video_handler,
)

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


@dataclass
class AppConfig:
    enabled: bool = True
    # add your knobs here (e.g., strength: float = 0.5)


class AppHandlers:
    """Fill in your processing logic inside the handlers below."""

    def __init__(self) -> None:
        self.cfg = AppConfig()
        # initialize your state here (e.g., model = None)

    @model_loader
    async def load(self, **_: dict) -> None:
        """Called once at stream start; load models or warm-up here."""
        logger.info("Model loader: initialize your pipeline here.")

    @video_handler
    async def handle_video(self, frame: VideoFrame) -> VideoFrame:
        """Process or passthrough the incoming video frame."""
        if not self.cfg.enabled:
            return frame

        # Example: passthrough implementation
        x = frame.tensor
        if x.dim() == 3 and x.shape[-1] == 3:
            # no-op example; replace with your logic
            return frame

        return frame

    @audio_handler
    async def handle_audio(self, frame: AudioFrame) -> List[AudioFrame]:
        """Process audio or return as-is."""
        if not self.cfg.enabled:
            return [frame]

        # Example: no-op
        return [frame]

    @param_updater
    async def update_params(self, params: dict) -> None:
        """Update configuration at runtime (via /control endpoint)."""
        if "enabled" in params:
            self.cfg.enabled = bool(params["enabled"])
        # add more params as needed

    @on_stream_stop
    async def on_stop(self) -> None:
        logger.info("Stream stopped; release resources if needed.")


async def main() -> None:
    handlers = AppHandlers()
    processor = StreamProcessor.from_handlers(
        handlers,
        name="my_app",
        port=8000,
    )

    # Run the processor indefinitely until interrupted
    await processor.run_forever()


if __name__ == "__main__":
    asyncio.run(main())
